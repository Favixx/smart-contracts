#include "imports/stdlib.fc";



;; msg_value — этот параметр сообщает нам, сколько монет TON (или граммов) получено с
;; этим сообщением.

;; in_msg — это полное сообщение, которое мы получили, со всей информацией о том, кто его
;; отправил и т. д. Мы видим, что оно имеет тип Cell. Что это значит? Тело сообщения хранится
;; в виде ячейки в TVM, поэтому нашему сообщению со всеми ее данными посвящена одна
;; целая ячейка.

;; in_msg_body — это собственно «читаемая» часть сообщения, которое мы получили. Он имеет
;; тип среза, поскольку является частью Ячейки, он указывает «адрес», с какой части ячейки
;; нам следует начать чтение, если мы хотим прочитать этот параметр среза.

;;нечистый спецификатор означает, что функция может иметь некоторые побочные эффекты,
;; которые нельзя игнорировать. Например, нам следует поставить нечистый спецификатор, если
;; функция может изменять хранилище контракта, отправлять сообщения или выдавать
;; исключение, когда некоторые данные недействительны, и функция предназначена для проверки
;; этих данных.


;;каждое получвенное сообщение имеет в себе ФЛАГИ состоящие из 4битов , которые нужно проверить
;;сам по себе slice хранит в себе указатель 

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    slice cs = in_msg.begin_parse(); ;;парсим входящее сообщение
    int flags = cs~load_uint(4); ;;парсим флаг из 4 битов
    slice sender_address = cs~load_msg_addr(); ;;получаем адрес отправителя

    set_data(begin_cell().store_slice(sender_address).end_cell()); ;;сохраняем адрес отправителя в хранилище типа c4


}
;;теперь стоит вопрос получения адреса извне конктракта
;;для этого необходимо создать функцию со спецификатором method_id
slice get_the_latest_sender() method_id {
    slice ds = get_data().begin_parse(); ;;считываем адрес
    return ds~load_msg_addr();
}